/*

TASK:

Подвиг 6. Продолжите программу. Объявите функцию с именем complex_sum и двумя параметрами, через которые передаются (с копированием) две структуры типа COMPLEX. Функция complex_sum должна складывать переданные комплексные числа по формуле (суммирование отдельно действительной и мнимой частей):

a
+
j
⋅
b
=
(
a
1
+
a
2
)
+
j
⋅
(
b
1
+
b
2
)
a+j⋅b=(a 
1
​
 +a 
2
​
 )+j⋅(b 
1
​
 +b 
2
​
 )

где j - мнимая единица (формально в структуре отсутствует). То есть, складываются отдельно действительные части (re) и мнимые (im) и записываются в новую созданную структуру типа COMPLEX внутри тела функции complex_sum. После сложения функция complex_sum должна возвращать сформированную структуру (через копирование).

В функции main объявите две переменные cmp_1, cmp_2 типа COMPLEX. Прочитайте из входного потока четыре вещественных числа, записанных в одну строчку через запятую. Первые два числа в порядке re, im сохраните в первой переменной cmp_1, а вторые два числа в том же порядке - во второй переменной cmp_2. Вызовите функцию complex_sum для сложения чисел cmp_1, cmp_2. Результат сохраните в переменной res типа COMPLEX.

P. S. В консоль ничего выводить не нужно.

*/

#include <stdio.h>

typedef struct
{
    double re; // действительная часть
    double im; // мнимая часть
} COMPLEX;

// здесь объявляйте функцию

COMPLEX complex_sum(COMPLEX n1, COMPLEX n2)
{
    return (COMPLEX){n1.re + n2.re, n1.im + n2.im};
}

int main(void)
{
    // здесь продолжайте функцию main

    COMPLEX cmp_1, cmp_2;
    if (scanf("%lf, %lf, %lf, %lf", &cmp_1.re, &cmp_1.im, &cmp_2.re, &cmp_2.im) != 4)
    {
        printf("Input error\n");
        return 0;
    }
    COMPLEX res = complex_sum(cmp_1, cmp_2);
   // __ASSERT_TESTS__ // макроопределение для тестирования (не убирать)
    return 0;
}
